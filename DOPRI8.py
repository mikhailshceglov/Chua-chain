import numpy as np

def dopri8_integrate(f, t_span, y0, t_eval, args=(), tol=1e-6, h_min=1e-8):
    t0, tf = t_span  # начало и конец отрезка интегрирования
    t = t0
    y = np.array(y0, dtype=float)  # начальное состояние

    # Начальный шаг
    h = (tf - t0) / 10000



    c = [
         0,
         1/18,
         1/12,
         1/8,
         5/16,
         3/8,
         59/400,
         93/200,
         5490023248/9719169821,
         13/20,
         1201146811/1299019798,
         1,
         1
        ]
    
    A = [
         [],  
         [1/18],
         [1/48,         1/16],
         [1/32,         0,        3/32],
         [5/48,         0,       -75/64,      75/64],
         [3/80,         0,        0,         3/16,       3/20],
         [29443841/614563906,   0,   0, 77736538/692538347, -28693883/1125000000, 23124283/1800000000],
         [16016141/946692911,   0,   0, 61564180/158732637,   22789713/633445777, 545815736/2771057229, -180193667/1043307555],
         [39632708/573591083,   0,   0, -433636366/683701615, -421739975/2616292301, 100302831/723423059, 790204164/839813087, 800635310/3783071287],
         [246121993/1340847787,  0,   0, -37695042795/15268766246, -309121744/1061227803, -12992083/490766935, 6005943493/2108947869, 393006217/1396673457, 123872331/1001029789],
         [-1028468189/846180014, 0,   0, 8478235783/508512852,  1311729495/1432422823, -10304129995/1701304382, -48777925059/3047939560, 15336726248/1032824649, -45442868181/3398467696, 3065993473/597172653],
         [185892177/718116043,   0,   0, -3185094517/667107341, -477755414/1098053517, -703635378/230739211, 5731566787/1027545527, 5232866602/850066563, -4093664535/808688257, 3962137247/1805957418, 65686358/487910083],
         [403863854/491063109, 0, 0,-5068492393/434740067, -411421997/543043805, 652783627/914296604, 11173962825/925320556, -13158990841/6184727034, 3936647629/1978049680, -160528059/685178525, 248638103/1413531060, 0]
        ]

    b = [
         14005451/335480064,
         0,
         0,
         0,
         0,
         -59238493/1068277825,
         181606767/758867731,
         561292985/797845732,
         -1041891430/1371343529,
         760417239/1151165299,
         118820643/751138087,
         -528747749/2220607170,
         1/4
        ]
    
    b_star = [
         13451932/455176623,
         0,
         0,
         0,
         0,
         -808719846/976000145,
         1757004468/5645159321,
         656045339/265891186,
         -3867574721/1518517206,
         465885868/322736535,
         53011238/667516719,
         2/45,
         0
        ]



    # Подготовка к накоплению решения
    ts = [t]      # времена интегрирования
    ys = [y.copy()]  # результаты интегрирования
    t_eval = np.array(t_eval)
    sol_t = []
    sol_y = []
    eval_idx = 0

    step_count = 0  

    while t < tf:
        if t + h > tf:
            h = tf - t
        
        # Вычисляем этапы
        k = []
        k1 = f(t, y, *args)
        k.append(k1)
        for i in range(1, 13): 
            ti = t + c[i] * h
            yi = y.copy()
            for j in range(i):
                yi += h * A[i][j] * k[j]
            ki = f(ti, yi, *args)
            k.append(ki)
        
        y8 = y.copy()
        y7 = y.copy()
        for i in range(13):
            y8 += h * b[i] * k[i]
            y7 += h * b_star[i] * k[i]
        
        # Оценка локальной ошибки
        err = np.linalg.norm(y8 - y7, ord=np.inf)
        
        # step_count += 1
        # print(f"Step {step_count}: t = {t:.6f}, h = {h:.6e}, err = {err:.6e}")
        
        # Если ошибка приемлема, переходим к следующему шагу
        if err < tol:
            t += h
            y = y8
            ts.append(t)
            ys.append(y.copy())
            # Сохраняем значения, попадающие в моменты из t_eval
            while eval_idx < len(t_eval) and t_eval[eval_idx] <= t:
                if len(ts) >= 2:
                    t_prev, t_curr = ts[-2], ts[-1]
                    y_prev, y_curr = ys[-2], ys[-1]
                    theta = (t_eval[eval_idx] - t_prev) / (t_curr - t_prev)
                    sol_y.append(y_prev + theta * (y_curr - y_prev))
                else:
                    sol_y.append(y.copy())
                sol_t.append(t_eval[eval_idx])
                eval_idx += 1

        # Корректировка шага
        s = (tol / err) ** (1/8)

        h = s * h
        if h < h_min:
            h = h_min


    sol_t = np.array(sol_t)
    sol_y = np.array(sol_y).T
    return {'t': sol_t, 'y': sol_y}
